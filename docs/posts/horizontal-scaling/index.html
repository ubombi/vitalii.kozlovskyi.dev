<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Horizontal Scaling | Personal buzzwords repository</title>
<meta name=keywords content="Scaling,Kafka,Cassandra,Postgres,SQL,NoSQL"><meta name=description content="Scale pragmatically. Understand your data, choose technologies wisely,
and design for future growth without overengineering. Keep services stateless,
use NoSQL only when truly needed, and prioritize solving current problems while
preparing for future scaling. The goal is to delay scaling as long as possible
while staying ready for when it becomes necessary."><meta name=author content><link rel=canonical href=https://vitalii.kozlovskyi.dev/posts/horizontal-scaling/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://vitalii.kozlovskyi.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://vitalii.kozlovskyi.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://vitalii.kozlovskyi.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://vitalii.kozlovskyi.dev/apple-touch-icon.png><link rel=mask-icon href=https://vitalii.kozlovskyi.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vitalii.kozlovskyi.dev/posts/horizontal-scaling/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Horizontal Scaling"><meta property="og:description" content="Scale pragmatically. Understand your data, choose technologies wisely,
and design for future growth without overengineering. Keep services stateless,
use NoSQL only when truly needed, and prioritize solving current problems while
preparing for future scaling. The goal is to delay scaling as long as possible
while staying ready for when it becomes necessary."><meta property="og:type" content="article"><meta property="og:url" content="https://vitalii.kozlovskyi.dev/posts/horizontal-scaling/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-22T14:48:41+02:00"><meta property="article:modified_time" content="2024-07-22T14:48:41+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Horizontal Scaling"><meta name=twitter:description content="Scale pragmatically. Understand your data, choose technologies wisely,
and design for future growth without overengineering. Keep services stateless,
use NoSQL only when truly needed, and prioritize solving current problems while
preparing for future scaling. The goal is to delay scaling as long as possible
while staying ready for when it becomes necessary."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vitalii.kozlovskyi.dev/posts/"},{"@type":"ListItem","position":2,"name":"Horizontal Scaling","item":"https://vitalii.kozlovskyi.dev/posts/horizontal-scaling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Horizontal Scaling","name":"Horizontal Scaling","description":"Scale pragmatically. Understand your data, choose technologies wisely,\nand design for future growth without overengineering. Keep services stateless,\nuse NoSQL only when truly needed, and prioritize solving current problems while\npreparing for future scaling. The goal is to delay scaling as long as possible\nwhile staying ready for when it becomes necessary.","keywords":["Scaling","Kafka","Cassandra","Postgres","SQL","NoSQL"],"articleBody":"Software products, especially SaaS, PaaS, or any other _aaS have a potential of explosive growth. It does not happen often though, and most start-ups fail or barely break even.\nNowadays, every application is expected to be global. And most of companies dream of acquiring 100% of their market niche. Which is not a wrong thing to do.\nScaling your product isn’t as simple as resizing an image, but it doesn’t have to be overwhelming.\nTL;DR: Scale pragmatically. Understand your data, choose technologies wisely, and design for future growth without overengineering. Keep services stateless, use NoSQL only when truly needed, and prioritize solving current problems while preparing for future scaling. The goal is to delay scaling as long as possible while staying ready for when it becomes necessary.\nThink big, implement incrementally Planning a global service, which can handle at least two time of the whole world population is a good mental exercise, but never a priority.\nAvoid premature optimization. Solve current problems efficiently, not hypothetical future issues. It’s not clever to throw money at a problem that does not even exists yet.\nPlan ahead, but focus on solving immediate challenges.\nBe Strategic: Avoid Scaling Pitfalls Some architectural decisions can cause significant issues if not carefully considered.\nFollow best practices to avoid common pitfalls in scaling.\nMore pragmatic approach is focusing on current scale and reasonable growth, while avoiding common mistakes, so we can easily improve it later.\nDesign for FUTURE Growth We can carefully cut most of the corners, and get back to them as needed. With userbase growth, product evolves in all directions.\nPlan your scaling path carefully to avoid future obstacles.\nHandling a server load may become quite a challenge, but managing teams is even harder task. And somehow we need to be prepared for both.\nHow? Know Your Data Always keep up-to-date relational diagram, for all the information that company works with. And make sure, it’s accessible within and across teams. This schema is rather informational and not enforceable.\nDefine the Ownership Each model should have an service/team that owns it. One that is responsible, for managing this data, and is a source-of truth, for denormalized values in other parts.\nMaking this surgical cut (when needed) based on data model is important for a few reasons:\nReduces dependencies, making teams and products more autonomous. Allows quick DB replacement, without dealing with dependencies. Reduces amount fo cross-service communication. Defines who is responsible to keep denormalized cache in sync with owner. Understand Consistency Requirements Assume, that any relation-field can be eventually consistent or even materialized by default. If not, mark them accordingly.\nallowing purchase of out-of-stock item can cause user frustration and company losses\nFor example, \"product\" page needs consistent \"stock\".quantity. And if we separate product catalog and warehouse management, this place will require some attention. At the same time for search or filtering by “in-stock” eventual consistency is usually enough.\nOn the other hand, we can assume that \"news\" article \"author\".name can be denormalized (materialized) in a news table, to avoid unnecessary DB dependency or cross-service communication in a read-heavy flow. Fetching it once, during article creation, should be enough.\nDifference - how it impacts end user:\nOld author’s lastname in year old article? - no one cares Once in a lifetime non-available product is shown in search? - barely noticeable You bought a product, which is not in stock? - that’s moderately annoying Know Your Partition Keys TL;DR: Make sure each SELECT/UPDATE has at least one field with WHERE closure, like foo = 'val' or bar IN ('val1', 'val2', 'valN') and avoid full table scans.\nNoSQL won’t save you. If data gets too large to fit into one computer, it must be spread across multiple of them. In simple words,\nYou may deploy a database per region, per client-company or any other business attribute. If clients are somewhat independent, we can skip attribute and onboard them into current server until it gets full, and then setup a new server for future clients. Etc.\nPartitioning is important, if we need to work with multiple data entities at once, with a dataset that can’t fit in a single server, in a cost efficient manner.\nList client devices Manage company employees List employee companies Find layers in city Show bandwidth by device group and hour Appropriate sharding key, depends on both the data and access pattern. Partitioning by reminder of Primary Key hash divided by cluster size, is the trick that most NoSQL databases use.\nDo you consider PostgreSQL or ElasticSearch to be horizontally scalable? They can be. Even SQLite can be with data partitioning.\nNoSQL: When and Why TL;DR: Use them as soon as you actually need them, but not before.\nNot want but need!\nChoose wisely.\nSo much misunderstanding there. It’s sad to see, the powerful technology being chosen mostly by it’s side-effect function.\nIt’s true, that most of them are designed with scaling in mind and are quite good at it, otherwise people will use relational DBs. But each of them solves a specific problem in efficient manner. And fails drastically if used for different purpose.\nDo you need a write performance at all costs?\nMaybe keep historical data for occasional analysis?\nHow about realtime alerting, or counters?\nWill user benefit from lower read latency, do you need it at all costs?\nCan we go offline or lose some data, without causing a disaster?\nWhat about consistency?… So many questions.\nYou can’t beat CAP Theorem, Choose tradeoffs wisely based on your business requirements. Remember, eventual consistency is often sufficient for many use cases and allows for better scalability.\nCassandra, Mongo, BigTable, Victoria Metrics, ClickHouse, DynamoDB, CouchBase… Do not limit yourself with technology choice from the beginning.\nThere is a high chance you’re wasting investors’ money.\nAt some point, knowing you data, access patterns and load, you will clearly understand what you need. When migrating (specific part) becomes economically reasonable, you introduce new technology to the project.\nDistributed Systems TL;DR: Keep your (micro) services stateless. You do not want to support and debug distributed synchronization.\nServices Cache invalidation is hard, but distributed consensus and distributed synchronization is even more so. It is painful. Unless you are writing a database or a queue, keep the state out of it.\nThis makes your application to be easily scalable, by simply deploying more. This makes code-base way simpler and smaller, focused on business requirements.\nEven if stateless implementation is less efficient, and may cost a bit more, it will work better in a long run.\nDistributed Transactions Try dividing product, that will avoid them. Or keep them to minimum. If not possible, it’s still okay, but require a bit more work.\nConclusion Balance future-proofing with solving current problems. Let your data guide technology choices and design decisions. This approach enables effective future scaling without unnecessary complexity or cost now.\nDelay scaling as long as possible, but be prepared for when it becomes necessary.\n","wordCount":"1152","inLanguage":"en","datePublished":"2024-07-22T14:48:41+02:00","dateModified":"2024-07-22T14:48:41+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://vitalii.kozlovskyi.dev/posts/horizontal-scaling/"},"publisher":{"@type":"Organization","name":"Personal buzzwords repository","logo":{"@type":"ImageObject","url":"https://vitalii.kozlovskyi.dev/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://vitalii.kozlovskyi.dev/ accesskey=h title="Personal buzzwords repository (Alt + H)">Personal buzzwords repository</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://vitalii.kozlovskyi.dev/cheatsheet/ title=CheatSheet><span>CheatSheet</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Horizontal Scaling</h1><div class=post-meta><span title='2024-07-22 14:48:41 +0200 CEST'>July 22, 2024</span>&nbsp;|&nbsp;<a href=https://github.com/ubombi/vitalii.kozlovskyi.dev/edit/master/content/posts/horizontal-scaling.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#think-big-implement-incrementally aria-label="Think big, implement incrementally">Think big, implement incrementally</a><ul><li><a href=#be-strategic-avoid-scaling-pitfalls aria-label="Be Strategic: Avoid Scaling Pitfalls">Be Strategic: Avoid Scaling Pitfalls</a></li><li><a href=#design-for-future-growth aria-label="Design for FUTURE Growth">Design for FUTURE Growth</a></li></ul></li><li><a href=#how aria-label=How?>How?</a><ul><li><a href=#know-your-data aria-label="Know Your Data">Know Your Data</a><ul><li><a href=#define-the-ownership aria-label="Define the Ownership">Define the Ownership</a></li><li><a href=#understand-consistency-requirements aria-label="Understand Consistency Requirements">Understand Consistency Requirements</a></li><li><a href=#know-your-partition-keys aria-label="Know Your Partition Keys">Know Your Partition Keys</a></li></ul></li><li><a href=#nosql-when-and-why aria-label="NoSQL: When and Why">NoSQL: When and Why</a></li><li><a href=#distributed-systems aria-label="Distributed Systems">Distributed Systems</a><ul><li><a href=#services aria-label=Services>Services</a></li><li><a href=#distributed-transactions aria-label="Distributed Transactions">Distributed Transactions</a></li></ul></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>Software products, especially SaaS, PaaS, or any other _aaS
have a potential of explosive growth. It does not happen often though,
and most start-ups fail or barely break even.</p><p>Nowadays, every application is expected to be global. And most of companies
dream of acquiring 100% of their market niche. Which is not a wrong thing to do.</p><figure><img loading=lazy src=/media/scaling/poster.png alt="Joke about scaling application like scaling image in editor"><figcaption><p>Scaling your product isn&rsquo;t as simple as resizing an image, but it doesn&rsquo;t have to be overwhelming.</p></figcaption></figure><blockquote><p><strong>TL;DR:</strong> Scale pragmatically. Understand your data, choose technologies wisely,
and design for future growth without overengineering. Keep services stateless,
use NoSQL only when truly needed, and prioritize solving current problems while
preparing for future scaling. The goal is to delay scaling as long as possible
while staying ready for when it becomes necessary.</p></blockquote><h2 id=think-big-implement-incrementally>Think big, implement incrementally<a hidden class=anchor aria-hidden=true href=#think-big-implement-incrementally>#</a></h2><p>Planning a global service, which can handle at least two time of
the whole world population is a good mental exercise, but never a priority.</p><p>Avoid premature optimization. Solve current problems efficiently,
not hypothetical future issues. It&rsquo;s not clever to throw money at a problem
that does not even exists yet.</p><p>Plan ahead, but focus on solving immediate challenges.</p><h3 id=be-strategic-avoid-scaling-pitfalls>Be Strategic: Avoid Scaling Pitfalls<a hidden class=anchor aria-hidden=true href=#be-strategic-avoid-scaling-pitfalls>#</a></h3><blockquote><p>Some architectural decisions can cause significant issues if not carefully considered.</p></blockquote><p><figure><img loading=lazy src=/media/scaling/time_bomb.png#center alt="image-icon of dynamite and a clock" height=200px></figure>Follow best practices to avoid common pitfalls in scaling.</p><p>More pragmatic approach is focusing on current scale and reasonable growth,
while avoiding common mistakes, so we can easily improve it later.</p><h3 id=design-for-future-growth>Design for FUTURE Growth<a hidden class=anchor aria-hidden=true href=#design-for-future-growth>#</a></h3><p>We can carefully cut most of the corners, and get back to them as needed.
With userbase growth, product evolves in all directions.</p><figure><img loading=lazy src=/media/scaling/planning.png#center alt="drawing with multiple rakes that person can step on"><figcaption><p>Plan your scaling path carefully to avoid future obstacles.</p></figcaption></figure><p>Handling a server load may become quite a challenge, but managing teams
is even harder task. And somehow we need to be prepared for both.</p><h2 id=how>How?<a hidden class=anchor aria-hidden=true href=#how>#</a></h2><h3 id=know-your-data>Know Your Data<a hidden class=anchor aria-hidden=true href=#know-your-data>#</a></h3><p>Always keep up-to-date relational diagram, for all the information that company
works with. And make sure, it&rsquo;s accessible within and across teams.
This schema is rather informational and not enforceable.</p><figure><img loading=lazy src=/media/scaling/data_model.png#center alt="drawing of ER diagram, splited into three parts"></figure><h4 id=define-the-ownership>Define the Ownership<a hidden class=anchor aria-hidden=true href=#define-the-ownership>#</a></h4><p>Each model should have an service/team that owns it. One that is
responsible, for managing this data, and is a source-of truth, for
denormalized values in other parts.</p><p>Making this surgical cut <em>(when needed)</em> based on data model is important
for a few reasons:</p><ul><li>Reduces dependencies, making teams and products more autonomous.</li><li>Allows quick DB replacement, without dealing with dependencies.</li><li>Reduces amount fo cross-service communication.</li><li>Defines who is responsible to keep denormalized cache in sync with owner.</li></ul><h4 id=understand-consistency-requirements>Understand Consistency Requirements<a hidden class=anchor aria-hidden=true href=#understand-consistency-requirements>#</a></h4><p>Assume, that any relation-field can be eventually consistent or even materialized
by default. If not, mark them accordingly.</p><p><figure><img loading=lazy src=/media/scaling/product_page.png#center alt="drawing of a product page in web shop"><figcaption><p>allowing purchase of out-of-stock item can cause user frustration and company losses</p></figcaption></figure>For example, <code>"product"</code> page needs consistent <code>"stock".quantity</code>. And if we separate
product catalog and warehouse management, this place will require some attention.
At the same time for search or filtering by &ldquo;in-stock&rdquo; eventual consistency is
usually enough.</p><p>On the other hand, we can assume that <code>"news"</code> article <code>"author".name</code> can be
denormalized <em>(materialized)</em> in a news table, to avoid unnecessary DB dependency or
cross-service communication in a read-heavy flow.
Fetching it once, during article creation, should be enough.</p><p>Difference - how it impacts end user:</p><ul><li>Old author&rsquo;s lastname in year old article? - no one cares</li><li>Once in a lifetime non-available product is shown in search? - barely noticeable</li><li>You bought a product, which is not in stock? - that&rsquo;s moderately annoying</li></ul><h4 id=know-your-partition-keys>Know Your Partition Keys<a hidden class=anchor aria-hidden=true href=#know-your-partition-keys>#</a></h4><blockquote><p><strong>TL;DR:</strong> Make sure each <code>SELECT</code>/<code>UPDATE</code> has at least one field with WHERE closure,
like <code>foo = 'val'</code> or <code>bar IN ('val1', 'val2', 'valN')</code> and avoid full table scans.</p></blockquote><p>NoSQL won&rsquo;t save you. If data gets too large to fit into one computer,
it must be spread across multiple of them. In simple words,</p><p>You may deploy a database per region, per client-company or any other business attribute.
If clients are somewhat independent, we can skip attribute and onboard them into
current server until it gets full, and then setup a new server for future clients.
Etc.</p><p>Partitioning is important, if we need to work with multiple data entities at once,
with a dataset that can&rsquo;t fit in a single server, in a cost efficient manner.</p><ul><li>List <strong>client</strong> devices</li><li>Manage <strong>company</strong> employees</li><li>List <strong>employee</strong> companies</li><li>Find layers in <strong>city</strong></li><li>Show bandwidth by <strong>device group</strong> and <strong>hour</strong></li></ul><p>Appropriate sharding key, depends on both the data and access pattern.
Partitioning by reminder of Primary Key hash divided by cluster size,
is the trick that most NoSQL databases use.</p><p>Do you consider PostgreSQL or ElasticSearch to be horizontally scalable?
They can be. Even SQLite can be with data partitioning.</p><h3 id=nosql-when-and-why>NoSQL: When and Why<a hidden class=anchor aria-hidden=true href=#nosql-when-and-why>#</a></h3><blockquote><p><strong>TL;DR:</strong> Use them as soon as you actually <strong>need</strong> them, but not before.<br>Not want but need!<br>Choose wisely.</p></blockquote><p>So much misunderstanding there. It&rsquo;s sad to see, the powerful technology
being chosen mostly by it&rsquo;s side-effect function.</p><p>It&rsquo;s true, that most of them are designed with scaling in mind and are quite
good at it, otherwise people will use relational DBs. But each of them solves
a specific problem in efficient manner. And fails drastically if used for different
purpose.</p><p>Do you need a write performance at all costs?<br>Maybe keep historical data for occasional analysis?<br>How about realtime alerting, or counters?<br>Will user benefit from lower read latency, do you need it at all costs?<br>Can we go offline or lose some data, without causing a disaster?<br>What about consistency?&mldr; So many questions.</p><p>You can&rsquo;t beat <a href=https://en.wikipedia.org/wiki/CAP_theorem>CAP Theorem</a>, Choose
tradeoffs wisely based on your business requirements. Remember,
eventual consistency is often sufficient for many use cases and allows
for better scalability.</p><p>Cassandra, Mongo, BigTable, Victoria Metrics, ClickHouse, DynamoDB, CouchBase&mldr;
Do not limit yourself with technology choice from the beginning.</p><blockquote><p>There is a high chance you&rsquo;re wasting investors&rsquo; money.</p></blockquote><p>At some point, knowing you data, access patterns and load, you will clearly
understand what you need. When migrating <em>(specific part)</em> becomes economically
reasonable, you introduce new technology to the project.</p><h3 id=distributed-systems>Distributed Systems<a hidden class=anchor aria-hidden=true href=#distributed-systems>#</a></h3><blockquote><p><strong>TL;DR:</strong> Keep your <em>(micro)</em> services <strong>stateless</strong>.
You do not want to support and debug distributed synchronization.</p></blockquote><h4 id=services>Services<a hidden class=anchor aria-hidden=true href=#services>#</a></h4><p>Cache invalidation is hard, but distributed consensus and distributed
synchronization is even more so. It is painful. Unless you are writing
a database or a queue, keep the state out of it.</p><p>This makes your application to be easily scalable, by simply deploying more.
This makes code-base way simpler and smaller, focused on business requirements.</p><p>Even if stateless implementation is less efficient, and may cost a bit more, it will
work better in a long run.</p><h4 id=distributed-transactions>Distributed Transactions<a hidden class=anchor aria-hidden=true href=#distributed-transactions>#</a></h4><p>Try dividing product, that will avoid them. Or keep them to minimum.
If not possible, it&rsquo;s still okay, but require a bit more work.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Balance future-proofing with solving current problems. Let your data guide
technology choices and design decisions. This approach enables effective
future scaling without unnecessary complexity or cost now.</p><p>Delay scaling as long as possible, but be prepared for when it becomes necessary.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vitalii.kozlovskyi.dev/tags/scaling/>Scaling</a></li><li><a href=https://vitalii.kozlovskyi.dev/tags/kafka/>Kafka</a></li><li><a href=https://vitalii.kozlovskyi.dev/tags/cassandra/>Cassandra</a></li><li><a href=https://vitalii.kozlovskyi.dev/tags/postgres/>Postgres</a></li><li><a href=https://vitalii.kozlovskyi.dev/tags/sql/>SQL</a></li><li><a href=https://vitalii.kozlovskyi.dev/tags/nosql/>NoSQL</a></li></ul><nav class=paginav><a class=next href=https://vitalii.kozlovskyi.dev/posts/kafka-oversimplified/><span class=title>Next »</span><br><span>Kafka Oversimplified Concepts</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Horizontal Scaling on x" href="https://x.com/intent/tweet/?text=Horizontal%20Scaling&amp;url=https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f&amp;hashtags=Scaling%2cKafka%2cCassandra%2cPostgres%2cSQL%2cNoSQL"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Horizontal Scaling on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f&amp;title=Horizontal%20Scaling&amp;summary=Horizontal%20Scaling&amp;source=https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Horizontal Scaling on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f&title=Horizontal%20Scaling"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Horizontal Scaling on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Horizontal Scaling on whatsapp" href="https://api.whatsapp.com/send?text=Horizontal%20Scaling%20-%20https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Horizontal Scaling on telegram" href="https://telegram.me/share/url?text=Horizontal%20Scaling&amp;url=https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Horizontal Scaling on ycombinator" href="https://news.ycombinator.com/submitlink?t=Horizontal%20Scaling&u=https%3a%2f%2fvitalii.kozlovskyi.dev%2fposts%2fhorizontal-scaling%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vitalii.kozlovskyi.dev/>Personal buzzwords repository</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>